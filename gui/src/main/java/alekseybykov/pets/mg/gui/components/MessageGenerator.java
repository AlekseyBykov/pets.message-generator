package alekseybykov.pets.mg.gui.components;

import alekseybykov.pets.mg.core.db.h2.H2ConnectionManager;
import alekseybykov.pets.mg.core.db.oracle.OracleConnectionManager;
import alekseybykov.pets.mg.core.db.oracle.OracleConnectionSwitcher;
import alekseybykov.pets.mg.core.utils.app.SingleInstanceChecker;
import alekseybykov.pets.mg.core.utils.tmpfile.TempFileUtils;
import alekseybykov.pets.mg.gui.config.ApplicationConfig;
import lombok.SneakyThrows;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

import javax.swing.*;

/**
 * Главный класс приложения, точка входа.
 *
 * После запуска приложения пользователю предлагается выбрать документ и вложения к нему. Связь один ко многим -
 * один документ и несколько вложений. Поддерживаемые форматы вложений:
 * - xml;
 * - zip;
 * - gzip.
 *
 * Вложения данных форматов могут быть добавлены все сразу в таблицу "Список загружаемых вложений".
 * При этом архивы могут содержать произвольное число xml-файлов.
 *
 * В каждом xml-файле могут быть указаны шаблоны $doc_uuid и $uuid, которые в процессе обработки заменяются на ГУИДы:
 * $uuid - если нужно сгенерировать случайные GUID;
 * $doc_uuid - если нужно сгенерировать случайный GUID, который будет подставлен и в тег xml,
 * и в поле DOC_GUID таблицы TB_MESSAGE_BIG_ATTRIBUTES.
 * Таким образом достигается связь по GUID загружаемого xml-документа и вложения
 *
 * В процессе обработки как самого документа, так и вложения, можно выделить ряд этапов с формированием временных
 * файлов. Например, если документ и вложение - xml-файлы:
 *
 * 1) xml-файл обрабатывается побайтно - выполняется поиск шаблонов $uuid/$doc_uuid (5-ти и 8-ми байтовые буферы),
 * которые заменяются на ГУИДы. В процессе данной обработки создается временный файл, закодированный в Base64:
 * из потоков для чтения в ОЗУ считываются буферы по 3Kb, где производится Base64 кодирование, далее закодированные буферы сбрасываются
 * на диск во временный файл.
 *
 * 2) Временный файл, полученный на этапе 1), декодируется из Base64 в исходный набор байт, но используются потоки InputStream/OutputStream,
 * которые сами по себе как структуры занимают незначительное место в ОЗУ и используются для передачи данных (байт). Т.о. обеспечивается
 * оптимальное использование ОЗУ, позволяющее пересылать файлы больших размеров (хотя существующий JDBC драйвер не позволит передать файл,
 * размер которого превышает 1.9Gb, а версия сервера БД совместима только с данной версией JDBC драйвера - и вообще,
 * сама идея хранить файлы таких размеров в БД - не самая удачная), т.к. в процессе всех преобразований мы оперируем минимальными
 * буферами (массивами байтов). В процессе декодирования создается еще один временный файл, но уже преобразованный на этапе 1)
 * и декодированный из Base64.
 *
 * 3) Из полученного на этапе 2) временного файла открывается поток на чтение, с помощью которого данные этого файла передаются
 * драйверу JDBC - в PreparedStatement#setBinaryStream. Т.о., в blob поля записываются данные исходного файла, который был добавлен как вложение -
 * при этом мы не манипулируем строками или символами - использование Base64 позволяет абстрагироваться от неизвестной кодировки
 * файла вложения и оперировать набором "сырых" байт. Т.к. файл представляет собой набор байт в той или иной кодировке, которую
 * нельзя менять в процессе вышепреведенных преобразований, иначе произойдет искажение данных, восстановить которые будет невозможно.
 *
 * 4) Драйвер JDBC закрывает переданный ему поток на чтение. Временные файлы удаляются при следующем запуске приложения.
 *
 * Если вложением является zip-архив, то к двум временным файлам на каждый файл в архиве добавляется еще временный каталог
 * с временными файлами - по одному на каждый файл в архиве. Т.е. zip-архив распаковывается во временный каталог, в нем содержатся копии
 * всех файлов оригинального архива. Далее каждый из этих файлов обрабатывается по приведенной выше схеме, получается Base64 encoded
 * файл и Base64 decoded файл. Из Base64 decoded файла открывается поток на чтение и данные также передаются в в PreparedStatement#setBinaryStream.
 * Аналогично, все временные файлы и каталоги удаляются при следующем запуске приложения.
 *
 * Если упоминаются временные файлы, каталоги или архивы - это значит, что данные файлы расположены в каталоге temp дистрибутива, либо в его подкаталогах.
 *
 * // todo Желательно найти способ реализовать декларативное управление транзакциями в условиях изменения параметров подключения "на лету"
 * // (переключение стендов) и уйти от plain JDBC на ORM.
 *
 * @author bykov.alexey
 * @since 01.05.2016
 */
public class MessageGenerator {

	/**
	 * Точка входа приложения.
	 */
	public static void main(String[] args) {

		if (SingleInstanceChecker.getInstance().isAlreadyRun()) {
			System.exit(0);
		}

		init();

		disableExtraBorders();
		SwingUtilities.invokeLater(new Runnable() {
			@SneakyThrows
			public void run() {
				new AnnotationConfigApplicationContext(ApplicationConfig.class).getBean(MainFrame.class);
			}
		});
	}

	/**
	 * Метод устраняет лишние обрамления в UI, если в панели используется JSplitPane.
	 * (бордеры под табами, вокруг основного лэйаута и тд.)
	 */
	private static void disableExtraBorders() {
		UIManager.getDefaults().put("SplitPane.border", BorderFactory.createEmptyBorder());
	}

	/**
	 * Метод выполняет инициализацию приложения.
	 */
	private static void init() {
		// Подключение к базе данных H2.
		connectH2DataBase();
		// Инициализация переключателя стендов.
		initOracleConnectionSwitcher();
		// Удаление всех временных файлов при запуске приложения.
		TempFileUtils.clearTempFolder();
	}

	/**
	 * Метод вынесен из {@link SwingWorker} в EDT, поскольку до выполнения запросов к БД H2
	 * необходимо создать ее здесь, если она не была создана ранее.
	 *
	 * (Вообще, следует реализовать более гибкий функционал подключения и инициализации/обновления БД H2).
	 */
	private static void connectH2DataBase() {
		H2ConnectionManager.connect();
	}

	private static void initOracleConnectionSwitcher() {
		OracleConnectionSwitcher.getInstance()
				.addSwitchListener(OracleConnectionManager.getInstance());
	}
}
